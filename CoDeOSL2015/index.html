<!DOCTYPE html>
<html>
  <head>
    <title>CoDeOSL2015: Unleash your features gradually</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="../styles/styles.css">
  </head>
  <body>
    <textarea id="source">

layout: true

<div class="theme">
  <img src="images/codeoslo2015.png" style="width: 100px;" />
</div>

---
class: center, middle, inverse

# Unleash your features gradually

.small.leftify[
_At FINN.no we are 140 developers deploying code to production multiple times a
day. We have a few web applications and a few hundred running micro-services in
production and integrate code in production even before new features are ready
for the end user. And when the feature is complete we gradually roll out the
new feature to our end users. This allows us to verify the performance of the
new feature and that it actually solves the user problem it targets. In this
talk I will briefly introduce the feature toggle technique in general and how
this allows us to separate deploy and release of new features. I will also
introduce Unleash, an open source feature toggle system, we developed to solve
this issue._]

#### Ivar Conradi Østhus <br /> Lead Developer <br /> FINN.no

???
- My name => Ivar Østhus
- I work as a developer for FINN.no
- In this talk I will:
 - present feature toggles
 - and how this simple technique allows us to release features gradually

<table class="bottom">
  <tr>
    <td class="rightify"><img src="images/twitter.png" height="20" /></td>
    <td class="leftify strong">@ivarconr</td>
  </tr>
  <tr>
    <td class="rightify"><img src="images/finn.png" height="20" /></td>
    <td class="leftify strong">ico@finn.no</td>
  </tr>
</table>
---
class: background-img

# master-branch == highway to production
<img src="images/highway.jpg">

.img-src[https://www.flickr.com/photos/ar88/4102692617/]

.box[
- **~140 developers**
- **~385 deployable** projects
- **~650 artifacts** deployed weekly (prod)
]

???
- In FINN:
 - We are about 140 devs doing 650 releases a week.
 - master branch ==> highway to production.
- Everything we check in to master:
 - built and integration tests executed
 - deployed to test-environments
 - Integration tests are executed
 - New code will be ready to be deployed to production with a push of a button

(We have a custom built pipeline system to manage all this.)

---
class: middle, center, inverse

# The master highway works well for <br /> small changes!

???
- The current setup is perfect for getting out small changes
 - minor feature tweaks
 - bug-fixes

---
# ...but not all changes are small
- **Some features requires more effort to be built**
 - days, weeks, months to be completed
 - multiple teams
 - multiple applications/services
- **Unfinished features**
 - can not be exposed to end users!
 - can not block the master branch!

???
- Some features requires more effort to be built
 - days, weeks, months
 - multiple teams, applications services involved
- Unfinished features
 - can not be available to the users
 - should not block the master highway


---
# Feature branches
<img class="fullwitdh border" src="images/feature_branch_simple.jpg" />

???
- The traditional way to isolate new code
- A separate branch for every new features
- New code will not hit production before you are ready.
- Feature branches:
 - Delays the integration cost

---
class: center, middle
<img  src="images/pull_request.png" style="width:50%;" />

???
- Pull Request
 - **the best thing about branch and merge approach!**
- Good support in many common tools:
 - GitHub
 - Stash
 - etc.

---
# Concurrent branches

<img class="fullwitdh border" src="images/feature_branch_double.jpg" />

???
 - Increased complexity with multiple branches
 - expensive to merge
 - We can reduce this by actively cost by syncing changes from master
 - How do we know that features work together?

---
class: background-img
<img  src="images/keep-refactoring-and-carry-on.png" />

???
Very hard to refactor the code when multiple concurrent branches exists
- framweworks and libraries
- __let's refactor later!__

---
# Feature Branches - Summary

**Pros:**
- Safe to commit code in separate branch
- No code will hit production before it is merged
- High degree of code isolation
- Code review via _pull-requests_

**Cons:**
- The *merge itself* can be very hard and costly!
- Difficult to share new code across branches
- Fear of refactoring shared code (frameworks / libs)
- How do we know that multiple features works well together?
- Continuous integration, testing, demonstration difficult


???
Pros:
- Simple and safe
- No code will go to production before it's merged back to master
- Easy to test out new stuff without affecting others
- The best think: **Code review via pull requests**

Cons:
- Expensive to merge
- Difficult to share new code across branches
- **Fear of refactoring**
- How do we know that multiple features works well together
- Difficult to present your new features

---
class: background-img
# Feature Toggles
<img src="images/Merrydown_Cider Factory.jpg">

.img-src[https://www.flickr.com/photos/howzey/3805038515]

???
**Feature Toggles is a simple technique**
- work on new features directly on master
- roll-out 'unfinished' code to production
- hides unfinished functionality from the user
- and it allows us to offer different experiences to different users

**Separates deploy and release of new features**
- Gives us control:
 - when and how new features will be rolled out to our users.
 - Gradual roll-out of new features
- Test new features early in production
- Reducing risk associated with larg
- Lightning fast roll-back



---
class: middle

.large[
```java
if(unleash.isEnabled("AwesomeFeature")) {
//do some magic
} else {
//do old boring stuff
}
```
]

???
A feature toggle is just a simple IF-condition


---

# Minimal impact!

.large[
- Use as few **```if statements```** as possible
- Protect the **entry point** (the link) for new UI-components
- _New API's_ does not need protection
 - (existing clients does not know them anyway!)
]

???
- Use as few ```if statements``` as possible
- Protect the entry point (link) for new UI-components
- _New APIs does not need protection_
 - existing clients does not know the capability



---
class: inverse, center, middle

# Decoupling <br /> .red[**deployment**] of code <br /> and <br /> .green[**release**] of new features


???
- deploy new code directly on master-branch
- helps to achieve the zero-downtime release.
- We can switch user from one version to the next
- enables developers to deploy new versions of application continuously
- completely independent of the decision as to which features are available
to which users.
- instantaneously rollback to previous release when required.


---
# Selective release

- Who should be exposed to a new feature?
- Test things on early users and react to their responses
- Detect problems before they get big


### ⇨ Gradual roll-out of features

???
Feature toggles
- a tool do selective release of new features
- only releasing our featuteres to a subset of our user-base.
- minimize the risk of releasing new features

---
class: inverse, middle
# Activation strategies

- Allows us to do selective release of our features


???
Feature toggles combined with activation strategies
⇨ this is where the fun begins!
- allows us to decide who we want to enable a new feature for!
- Allows us to unleash our new features gradually

---

# Activation strategies

.large[
Rules that decides when a _feature toggle_ is active
- basic on/off
- user
- role / permission
- date
- server-node
]

** ⇨ Gradual roll-out of new features**

???
- rules that decides when a toggle is active.
Many different kinds:
- For specific user, e.g. only for my team
- For specific roles or classes of users. E.g. Beta users
- Test feature with full load, but only on one server,
**again to minimize risk!**


---

# Increased control
.large[
- Allows us to **test** the new feature on a limited group
- **Verify** that the new feature solves real user problems
- Lightning fast **rollback** if problems are detected
- **Iterate** the new feature to make it better

]

???

**Feature Foggles**
- Gives increased control of access to new feature
- Makes it safer to push code out!
- Allows us to verify our new feature, before exposing it to **everyone**
- Fast and simple to roll it back:
 - if we discover errors
 - if the new feature is not performing
- **Iterate until we are done!**

---
class: inverse, center, middle

# development ≠ production

???
- We all know this, even though we wont admit it.
- Feature toggles enables us to test features in production with real data
- **Is the firewall really open???**

---
class: background-img
<img src="images/pollution.jpg">

# Clean up your mess!

.img-src[https://www.flickr.com/photos/epsos/5444678656/]

.box[
- Feature toggles are technical depth!
- Review your toggles often
- Avoid permanent toggles (if you can)
]

???
- A feature toggle is technical depth from the moment it is created
 - each toggle is a new if-statement
 - represent a new path in the application
- Review flags often
- Delete feature toggles
 - when you are finished with them
 - Very costly to maintain over team
- Avoid permanent 'feature toggles' when possible
 - Makes the application harder to reason about
 - Why is this toggle on?



---
class: background-img
# No silver bullet!
<img src="images/silver_bullet.jpg">

.box[
- How to test?
- Bugs might be hidden for you
 - You see something else than your users
- Harder to reason about the code
]

.img-src[https://www.flickr.com/photos/eschipul/4160817135]

???
**How to test?**
- Each toggle represent a new path in your application
- General advice:
 - **not test all possbible combination*
- Test your code:
 - with the same toggle configuration you expect in production!

**You see something else!!?**
- Having a toggle turned on for yourself makes you see somehting different than your users!

---

# Avoid feature toggles if you can!

.blockquote[Release toggles are a useful technique and lots of teams use them. However
they should be your last choice when you're dealing with putting features into
production.
<br />
<br />
Your first choice should be to break the feature down so you can safely
introduce parts of the feature into the product. The advantages of doing this
are the same ones as any strategy based on small, frequent releases. You reduce
the risk of things going wrong and you get valuable feedback on how users actually
use the feature that will improve the enhancements you make later.
]
.author[Martin Fowler]



???
- A new feature is a risk until it is **in use by real users.**
- Try to split up features first, only use feature toggles if necessary.
- They should not be an excuse to delay releases, they should be a reason
to release stuff more often!


---
class: center
# Life-cycle of a feature toggle

<img class="border" style="width: 60%;" src="images/feature_toggle_lifecycle.jpg" />

???

This life-cycle by just changing the activation strategy.

1. Start working on a new feature (disabled in production)
2. Enable the new feature for the team
3. Enable the feature to a percentage of the users
4. Enable the feature for everyone
5. **Delete the feature toggle.** when you are done with it

---

# Unleash

.large[
- Feature toggles framework
 - Developed by FINN.no
 - All our _feature toggles_ in the same dashboard
 - A shared and robust client
 - KISS!
- Multi-platform
 - Implementations for Java and Node
- **It's open source!**
 - https://github.com/finn-no/unleash
]

???
- We started out with multiple simple toggle systems in FINN
- Configuration files, database-tables etc.
- Feature toggling => Fairly general problem
- we wanted to have all toggles in one system for simplicity
- Make it dead simple for developers to take advantage of feature toggles.
- Right now we have XXX toggles in FINN.


---
# Unleash :: System overview

<img src="images/unleash_system.png" style="width: 100%;">

???
Unleash consists of three parts:
1. unleash-service - a simple micro-service
2. Unleash Admin - Dashboard for create and update feature toggles
3. Unleash-clients(er) - Client-library for using feature toggling
in the applications.


---

# Unleash :: The Admin Panel

- Define new feature toggles
- Enable / disable feature toggles
- Choose and configure activation strategies
- Define new strategies


.right[
<img src="images/unleash_admin.png" style="width: 500px;border: 1px solid gray;">
]

---
# Unleash :: The Client
- The robust client
- Local in-memory representation
- Local persisted last-known representation
- Poll-based updates via REST
- Multiple implementations:
 - Java Client - https://github.com/finn-no/unleash-client-java
 - Node Client - https://github.com/finn-no/unleash-client-node

???
- The robust, and kind of **fat**, client

---
class: center, middle, inverse
# Unleash is open source

Feel free to use it, contribute and suggest improvements!

#### https://github.com/finn-no/unleash

---
## Feature toggles - summary

#### Pros
- No merge problems
- Allows us to deploy our code often
- Decoupling deployment and release
- Safer to refactor code on master branch
- Lightning fast rollback if problems are detected
- Selective release via activation strategies
- Iterate and improve new features
- Test new features in production

#### Cons
- Feature toggles are technical depth
- Accidental exposure of unfinished features
  - can be a security risk
- Testing becomes harder
- The code will be more fragile and harder to understand
- Long lived toggles are very costly!


???
- the main purpose of toggles is to perform release with minimum risk,
once release is complete toggles need to be removed.
- Feature Flags need to be Short Lived
- eliminating the costs of maintaining and supporting long-lived branches.

---

# You should still use branches!

.large[
- But not for complete features!
- They should be short lived
- And you should use pull requests to get a good review process with your team
]

---
class: inverse, center, middle

# use feature toggles to .red[reduce risk]
# and
# .green[unleash your features gradually]

<br /<br />
#### (remember to clean up your mess!)



---
class: middle inverse

# Questions?
<br />
<br />
### Resources used:
.small[
- https://github.com/finn-no/unleash
- https://github.com/ivarconr/feature-toggles-presentation
- http://martinfowler.com/bliki/FeatureToggle.html
- http://swreflections.blogspot.no/2014/08/feature-toggles-are-one-of-worst-kinds.html
- http://technologyconversations.com/2014/08/26/feature-toggles-feature-switches-or-feature-flags-vs-feature-branches/
- http://abhishek-tiwari.com/post/decoupling-deployment-and-release-feature-toggles
- http://www.slideshare.net/jug-berlin-brandenburg/feature-toggles-on-steroids
]

<table class="bottom">
  <tr>
    <td class="rightify"><img src="images/twitter.png" height="20" /></td>
    <td class="leftify strong">@ivarconr</td>
  </tr>
  <tr>
    <td class="rightify"><img src="images/finn.png" height="20" /></td>
    <td class="leftify strong">ico@finn.no</td>
  </tr>
</table>

    </textarea>
    <script src="../scripts/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>


  </body>
</html>
